<p>At the start of the 2020 school year I wanted to learn more about compilers so I started writing a compiler for the ez programming language that I made up. I did this as an independent study for school. I wanted to grow <em>dramatically</em> as a thinker and learn a lot about computer science and compilers in specific. If you just want to see the project head to <a href="https://github.com/g-w1/ezc">github.com/g-w1/ezc</a> or <a href="https://g-w1.github.io/ezc/">g-w1.github.com/ezc</a> for documentation.</p>

<blockquote>
  <p>Note: I may make some mistakes in this post. If that happens, please send me an email and Iâ€™ll correct it.
The code examples in this post were taken from an earlier stage of my compiler and are simplified a little.</p>
</blockquote>

<h1 id="why-i-chose-rust">Why I Chose Rust</h1>

<p>I chose Rust for this because I wanted to learn it and it is just a very cool language. If you donâ€™t know of it, I think of it as aiming to be a replacement to C++. Some language features that make it very easy to write a compiler in are:</p>

<p><strong>Enums (algebraic data types)</strong></p>

<p>Algebraic data types are most present in functional languages (haskell, ocaml, etc).</p>

<p>These allow for efficient representation of tokens and nodes of an abstract syntax tree in memory. In c one could think of them as tagged unions. For example my Expression type is defined as this</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">enum</span> <span class="n">Expr</span> <span class="p">{</span>
    <span class="cd">/// an identifier</span>
    <span class="nf">Iden</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="cd">/// a binop</span>
    <span class="n">BinOp</span> <span class="p">{</span>
        <span class="n">lhs</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">op</span><span class="p">:</span> <span class="n">BinOp</span><span class="p">,</span>
        <span class="n">rhs</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This means an expression is either a number, an identifier (variable name), or a combination of 2 expressions with a Binary operator in between. It is defined as Box<Expr> because recursive data types are not allowed, so it has to be a pointer (a box is basically a pointer to the heap)</Expr></p>

<p><strong>Pattern Matching</strong></p>

<p>Along with algebraic data types, pattern matching comes. It is used to destructure an enum into the parts that it is made up of. It is best explained with an example:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">match</span> <span class="n">e</span> <span class="p">{</span> <span class="c1">// e is the expression we are matching against</span>
  <span class="nn">Expr</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"It is a number: {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
  <span class="nn">Expr</span><span class="p">::</span><span class="nf">Iden</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"It is an identifier: {}"</span><span class="p">,</span><span class="n">i</span><span class="p">),</span>
  <span class="c1">// This will capture everything and put it in a fallback variable. We know is has to be a BinOp Expr because that is all that is left</span>
  <span class="n">recurse</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Uh-oh we do not know how to do recursive expressions yet: {:?}"</span><span class="p">,</span> <span class="n">recurse</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As you can imagine, Rust enums are <strong>so</strong> cool. Most of the higher level types in my compiler are enums compared to structs. I canâ€™t imagine doing this in a language like c where I would have to use many layers of tagged unions and structs to achieve the same.</p>

<p>Enums and Pattern Matching were the main reasons I chose Rust over something like Python. Another reason is probably the strong typing. It makes it soo much easier to debug your program when you know exactly what each function will return.</p>

<p>The last reason I chose Rust over a language like c++ is because of the safety guarantees. It makes your life easier when you can debug why the assembly code your compiler is generating is segfaulting rather than why the compiler is segfaulting ðŸ˜€.</p>

<h1 id="structure">Structure</h1>

<p>The structure of my compiler looks like this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Parse</span> <span class="kt">Commands</span> <span class="o">-&gt;</span> <span class="kt">Lexer</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="o">-&gt;</span> <span class="kt">Semantic</span> <span class="kt">Analyzer</span> <span class="o">-&gt;</span> <span class="kt">Code</span> <span class="kt">Generator</span> <span class="o">-&gt;</span> <span class="kt">Write</span> <span class="kt">To</span> <span class="kt">File</span> <span class="o">-&gt;</span> <span class="kt">Link</span>
</code></pre></div></div>

<p><strong>Parse Commands</strong></p>

<p>The command line parsing is very simple. I just use <code class="language-plaintext highlighter-rouge">std::env::args</code> in Rust to get a <code class="language-plaintext highlighter-rouge">Vec&lt;String&gt;</code>. I just use the 1st arg to get the file to compile and then just use a loop to get the rest. It is pretty easy.</p>

<p><strong>Lexing</strong></p>

<p>The Lexer is next. It takes the source code and breaks it up into tokens. Each token is an option in a <code class="language-plaintext highlighter-rouge">Token</code> enum. The definition looks something like this</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">enum</span> <span class="n">Token</span> <span class="p">{</span>
    <span class="c1">// Keyword Tokens</span>
    <span class="cd">/// kword for set</span>
    <span class="n">Kset</span><span class="p">,</span>
    <span class="cd">/// kword for Change</span>
    <span class="n">Kchange</span><span class="p">,</span>
    <span class="cd">/// to</span>
    <span class="n">Kto</span><span class="p">,</span>
    <span class="cd">/// If</span>
    <span class="n">Kif</span><span class="p">,</span>
    <span class="cd">/// Loop</span>
    <span class="n">Kloop</span><span class="p">,</span>
    <span class="cd">/// break</span>
    <span class="n">Kbreak</span><span class="p">,</span>
    <span class="cd">/// Function</span>
    <span class="n">Kfunc</span><span class="p">,</span>
    <span class="cd">/// Return</span>
    <span class="n">Kreturn</span><span class="p">,</span>
    <span class="c1">// Iden tokens</span>
    <span class="cd">/// Identifier token</span>
    <span class="nf">Iden</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="cd">/// IntLit token</span>
    <span class="nf">IntLit</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="cd">/// EndOfLine token (.)</span>
    <span class="n">EndOfLine</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The way the lexer works is through a state machine:
The states are represented by this enum:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">LexerState</span> <span class="p">{</span>
    <span class="n">Start</span><span class="p">,</span>
    <span class="n">InWord</span><span class="p">,</span>
    <span class="n">InNum</span><span class="p">,</span>
    <span class="n">SawLessThan</span><span class="p">,</span>
    <span class="n">SawEquals</span><span class="p">,</span>
    <span class="n">SawGreaterThan</span><span class="p">,</span>
    <span class="n">SawBang</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then to lex I just iterate through all the characters in the input string and match to them with the state. If I see a <code class="language-plaintext highlighter-rouge">'&lt;'</code> and am in the <code class="language-plaintext highlighter-rouge">Start</code> state, then I will set the state to <code class="language-plaintext highlighter-rouge">SawLessThan</code>. Then if I see an <code class="language-plaintext highlighter-rouge">'='</code>, I will append a <code class="language-plaintext highlighter-rouge">GreaterEquals</code> token and set the state to start, and if I see anything else, I will append a <code class="language-plaintext highlighter-rouge">GreaterThan</code> and set the state to start and go one character back. If I am in the <code class="language-plaintext highlighter-rouge">InNum</code> state and see a number, then I will append it to the intermediate string and keep going. If I see something else, then I will set the character back one and set the state to <code class="language-plaintext highlighter-rouge">Start</code>. I think you get the gist of this approach.</p>

<p>To get an idea of even <em>how</em> to write a Tokenizer/lexer I started reading the source code of the <a href="https://github.com/ziglang/zig">zig</a> programming language (it is aimed to be a replacement to c). The codebase is in c++/zig which is similar enough to Rust to understand. It is also relatively small. It is in just one flat directory with around 30 files. I found this much easier to navigate than the <a href="https://github.com/rust-lang/rust">Rust</a> codebase, which has <em>tons</em> of directories. I would recommend the zig language for learning how to write a language.</p>

<p><strong>Parsing</strong></p>

<p>The Parser is a little more complicated than the Lexer. It is a recursive descent parser, which means that it can call itself. I wrote small helper functions to do small, repetitive tasks in the compiler, and then functions to parse different types of <code class="language-plaintext highlighter-rouge">Ast</code> elements. This is an example of the function that parses a function.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Function &lt;- FnProto OpenBlock Ast CloseBlock</span>
<span class="k">fn</span> <span class="nf">parse_func</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AstNode</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">ParserError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.expect_eat_token</span><span class="p">(</span><span class="nn">Token</span><span class="p">::</span><span class="n">Kfunc</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.parse_func_proto</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
    <span class="k">self</span><span class="nf">.expect_eat_token</span><span class="p">(</span><span class="nn">Token</span><span class="p">::</span><span class="n">Comma</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">body</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.parse</span><span class="p">(</span><span class="k">false</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">self</span><span class="nf">.expect_eat_token</span><span class="p">(</span><span class="nn">Token</span><span class="p">::</span><span class="n">ExclaimMark</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="n">tree</span><span class="nf">.push</span><span class="p">(</span><span class="nn">AstNode</span><span class="p">::</span><span class="n">Func</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">args</span><span class="p">,</span>
        <span class="n">body</span><span class="p">,</span>
        <span class="n">vars_declared</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can see it calls the parse function. The arg it takes is a <code class="language-plaintext highlighter-rouge">bool</code> that tells it whether it is top-level of not. We call it with false here because it is parsing inside the function. It also calls <code class="language-plaintext highlighter-rouge">parse_func_proto</code>, another helper function.</p>

<p>Another reason why I like Rust is because of itâ€™s error system. The question mark <code class="language-plaintext highlighter-rouge">?</code> operator is used for a function that can return an error. You can kind of think of it like a monad binding in Haskell except now it only supports <code class="language-plaintext highlighter-rouge">Option</code> and <code class="language-plaintext highlighter-rouge">Result</code>. If the function returns an error it will be passed along, but if the function does not return an error, then the error will be unwrapped. The error type in rust is <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code>; it is an Enum. The question mark is just syntactic sugar for</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">unwraped_res</span> <span class="o">=</span> <span class="k">match</span> <span class="nf">func_that_returns_result</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">Ok</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">o</span><span class="p">,</span>
  <span class="n">e</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="n">e</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The rest of the parser is fairly straightforward. I just have a giant <code class="language-plaintext highlighter-rouge">match</code> statement that matches on all types of statements and then dispatches to the function that handles that type of statement.</p>

<p><strong>Semantic Analysis</strong></p>

<p>This part was not very hard to implement, but it was <em>very</em> fun. I have it as an analyzer struct:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Analyser</span> <span class="p">{</span>
    <span class="cd">/// the initialized_static_vars</span>
    <span class="n">initialized_static_vars</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// the initialized_local_vars</span>
    <span class="n">initialized_local_vars</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// the initialized_function_names</span>
    <span class="n">initialized_function_names</span><span class="p">:</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">initialized_function_vars</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="cd">/// scope that the analizer is in rn</span>
    <span class="n">scope</span><span class="p">:</span> <span class="n">Scope</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I make ample use of <code class="language-plaintext highlighter-rouge">std::collections::HashMap</code> and <code class="language-plaintext highlighter-rouge">HashSet</code> in the analyzer and the code generator. The latter is just a wrapper over <code class="language-plaintext highlighter-rouge">HashMap&lt;T, ()&gt;</code> for using a set with near constant time lookup whether something is in it.</p>

<p>This captures all of the variables that are initialized in every scope and a scope struct that looks like this:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Scope</span> <span class="p">{</span>
    <span class="n">in_if</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">in_loop</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">in_func</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>From here, I just have to recursively descend the Ast in a form of a <code class="language-plaintext highlighter-rouge">Vec&lt;AstNode&gt;</code> that is recursively traversed by <code class="language-plaintext highlighter-rouge">Analyser::analyze</code> on <code class="language-plaintext highlighter-rouge">Analyser</code>.</p>

<p>Here is an example method in <code class="language-plaintext highlighter-rouge">Analyser</code>:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// a helper function to make sure a variable exists</span>
<span class="k">fn</span> <span class="nf">make_sure_var_exists</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="n">AnalysisError</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.scope.in_func</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.initialized_local_vars</span><span class="nf">.contains_key</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">self</span><span class="py">.initialized_static_vars</span><span class="nf">.contains</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">AnalysisError</span><span class="p">::</span><span class="nf">VarNotExist</span><span class="p">(</span><span class="n">var</span><span class="nf">.to_owned</span><span class="p">()));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="py">.initialized_function_vars</span><span class="nf">.contains_key</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">AnalysisError</span><span class="p">::</span><span class="nf">VarNotExist</span><span class="p">(</span><span class="n">var</span><span class="nf">.to_owned</span><span class="p">()));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The analyzer also modifies some of the ast nodes and adds the variables declared in them to them. This helps the code generator. I did not use an intermediate representation since I am not doing any code optimisation, but it seems <em>really</em> interesting. Ill definitely look into it in the future. Maybe for zigâ€™s self-hosted compiler. I actually came up with the exact same method of adding <code class="language-plaintext highlighter-rouge">Option&lt;_&gt;</code> fields to the Ast that would be mutated by the Analyser as Tristan Hume did when <a href="https://thume.ca/2019/04/18/writing-a-compiler-in-rust/">writing his compiler</a> without even knowing it! His blog post actually was the original thing that inspired my interest in compilers, but I didnâ€™t understand a lot of it. Now I do!</p>

<p><strong>Code Generation</strong></p>

<p>This was the hardest part by far to implement. That will make it more fun to talk about!</p>

<p>I have a struct <code class="language-plaintext highlighter-rouge">Code</code> that tries to mirror assembly with sections. It has <code class="language-plaintext highlighter-rouge">text</code> and <code class="language-plaintext highlighter-rouge">bss</code>. These each have <code class="language-plaintext highlighter-rouge">instructions</code> which is a <code class="language-plaintext highlighter-rouge">Vec&lt;String&gt;</code>. In hindsight, it would have been simpler to just have a <code class="language-plaintext highlighter-rouge">String</code> instead of <code class="language-plaintext highlighter-rouge">Vec&lt;String&gt;</code> for storing the code.</p>

<blockquote>
  <p>Note about optimisation: In this compiler, I am not worried about optimisation of the <em>compiler</em>. This is why I use types like <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">Vec</code> that are heap allocated a lot. The compiler is still pretty fast, I assume this is because the lack of optimisation in the generated code and the fact that it is ~1.3 pass (I count sorting the Ast as .2 and removing <code class="language-plaintext highlighter-rouge">_start</code> if compiling for a library as .1).</p>
</blockquote>

<p>Then I just loop over the Ast and do code generation. The part that I found the <em>most</em> interesting was stack allocation. It took me about a week to think of an algorithm to impliment this. First of all, stack allocation is used where the data is deallocated after it goes out of scope (when the function or if statement ends). It is actually so difficult that I have to keep track of the stack pointer offset in code. The general algorithm looks something like this:</p>

<ol>
  <li>At the time of allocation, insert into a <code class="language-plaintext highlighter-rouge">HashMap&lt;String, u32&gt;</code> (lets call it <code class="language-plaintext highlighter-rouge">initalized_vars</code>) the name of the var, current stack pointer - the place of the var that is initialized in all the vars that were initialized in that block.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">self</span><span class="py">.initalized_vars</span><span class="nf">.insert</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span> <span class="k">self</span><span class="py">.stack_p_offset</span> <span class="o">-</span> <span class="n">place</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>To find the offset of that variable from the current stack pointer just look up in <code class="language-plaintext highlighter-rouge">initalized_vars</code> the variable name and take the value and subtract it from the current stack pointer to get the offset from the current stack pointer.
    <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">self</span><span class="py">.stack_p_offset</span> <span class="o">-</span> <span class="k">self</span><span class="py">.initalized_vars</span><span class="nf">.get</span><span class="p">(</span><span class="n">varname</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>Yeah, that algorithm took me a <em>really</em> long time to come up with, but it payed off in the end. If you have a better one, please tell me :). I have taken I deeper look at the codegen in the zig programming language and it seems like they use this <a href="https://github.com/ziglang/zig/blob/03ae77b8b02eef4da09a6b0de12d6fb0192b81d4/src/codegen.zig#L320">same algorithm</a>, so I think its good. When implementing arrays, I used a slight variation on this algorithm.</p>

<p>Since I also support writing libraries, I have an option to filter out <code class="language-plaintext highlighter-rouge">_start</code> when generating the code.
Here is an example method to generate code for an expression:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// code generation for an expr. moves the result to r8</span>
<span class="k">fn</span> <span class="nf">cgen_expr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">expr</span> <span class="p">{</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="n">BinOp</span> <span class="p">{</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">rhs</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.cgen_binop_expr</span><span class="p">(</span><span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">rhs</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.text.instructions</span><span class="nf">.push</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"pop r8"</span><span class="p">));</span>
            <span class="c1">// we decriment the stack_p_offset by 1 because we pop off the stack</span>
            <span class="k">self</span><span class="py">.stack_p_offset</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="nf">Number</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">self</span><span class="py">.text.instructions</span><span class="nf">.push</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"mov r8, {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">)),</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="nf">Iden</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.cgen_get_display_asm</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">Expr</span><span class="p">::</span><span class="nf">Iden</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
            <span class="k">self</span><span class="py">.text.instructions</span><span class="nf">.push</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"mov r8, {}"</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="nn">Expr</span><span class="p">::</span><span class="n">FuncCall</span> <span class="p">{</span>
            <span class="n">func_name</span><span class="p">,</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="n">external</span><span class="p">,</span>
        <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.cgen_funcall_expr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">func_name</span><span class="p">,</span> <span class="n">external</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="k">true</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="nf">DerefPtr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.cgen_get_display_asm</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">Expr</span><span class="p">::</span><span class="nf">Iden</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
            <span class="k">self</span><span class="py">.text.instructions</span><span class="nf">.push</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"mov r8, {}"</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
            <span class="k">self</span><span class="py">.text.instructions</span><span class="nf">.push</span><span class="p">(</span><span class="nd">format!</span><span class="p">(</span><span class="s">"mov r8, [r8]"</span><span class="p">,));</span>
        <span class="p">}</span>
        <span class="nn">Expr</span><span class="p">::</span><span class="nf">AccessArray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.cgen_access_array</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">e</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><strong>Write To File and Link</strong></p>

<p>This was also very easy. I just used <code class="language-plaintext highlighter-rouge">std::fs::write()</code> to write the assembly and then used <code class="language-plaintext highlighter-rouge">std::process::Command</code> to run <code class="language-plaintext highlighter-rouge">nasm</code> and <code class="language-plaintext highlighter-rouge">ld</code>.</p>

<h1 id="standard-library">Standard Library</h1>

<p>No programming language is complete without a standard library. To implement the standard library of ez, I used the zig programming language. I chose this for a few reasons: it is very easy to compile a library with zig, and I wanted to learn zig. Now I am contributing to the zig compiler! The only challenging thing was integrating with how arrays work in ez. The memory layout of arrays is slightly different. You can see the standard library <a href="https://github.com/g-w1/ezc/blob/master/lib/src/lib.zig">here</a>.</p>

<h1 id="what-i-learned-from-this">What I learned from this</h1>

<p>I am really glad I chose to write a compiler (and standard library). It took ~50 hours, but it was worth it. I learned so much about programming.</p>

<p>Here is a list of things I learned:</p>

<ul>
  <li>Testing: I have not done very much testing in previous projects so in this project I did. Iâ€™m not really sure what type of testing it was. I tested the compiler and the stdout from the generated code. The compiler tests were testing the generated data structures for the lexer and parser and regression tests for the analyzer and code generator. I implemented the stdout tests with 2 scripts. <code class="language-plaintext highlighter-rouge">gen_output.sh</code> would run every .ez file in the tests directory and store its output. <code class="language-plaintext highlighter-rouge">test.sh</code> would run every .ez file in the tests directory and check it against what <code class="language-plaintext highlighter-rouge">gen_output.sh</code> generated. Even if I didnâ€™t catch many bugs with all this testing, it felt satisfying to see ~60 tests passing! I also setup Github Actions and had it run the tests on any pushes to master. I ran into a weird bug with nasm, my assembler, in which the feature set on Ubuntu (github actions) was different than on Arch Linux (my distro). I had to dumb down some code so that it would also run on Ubuntu.</li>
  <li>Recursion: I had known about recursion before writing this compiler, and had implemented some recursive algorithms, but I felt this really cemented the idea in my head. With 2 of the 4 main compiler steps using a recursive algorithm (parsing and analyzing) I feel like I have a very good understanding of recursion. I also discovered a pattern with recursive methods on a struct. This way, data can be shared between methods without passing it between functions in a cumbersome way.</li>
  <li>General Software Design: I feel like I have just learned a lot about designing software from this project. It is biggest project I have made and I am pretty happy with the design. The code for lexing, parsing, and analyzing is pretty nice. The code quality goes downhill when you get to <code class="language-plaintext highlighter-rouge">codegen.rs</code>. I attribute this to not using recursion: this method requires a lot of repeated code that could be avoided with recursion.</li>
  <li>Low Level Programming: I learned about linking, assembling, calling conventions, and much more.</li>
</ul>

<h1 id="whats-next">Whatâ€™s Next</h1>

<p>My journey about learning about compilers is just starting! I have so much to learn. From the time I was done with ez to the time this blog post was published and onwards I have started <a href="https://github.com/ziglang/zig/pulls?q=author%3Ag-w1">contributing to zig</a> and <a href="https://github.com/marler8997/zigup/pulls?q=author%3Ag-w1">related projects</a>. I can see myself doing this for a while longer. I have found that reading high quality code is a very good method of learning. I eventually want to learn about operating systems and the linux kernel and will have to learn c or c++ eventually :(. I might want to write a shell in c to learn about linux syscalls. I also want to take ap computer science soon, so will have to learn Java :(. Hopefully, I come to like these languages even though I donâ€™t think I will. Until my next blog post, keep learning!</p>
