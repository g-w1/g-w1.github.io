<h1 id="my-question-was-answered">My Question Was Answered</h1>
<p>In the <a href="https://g-w1.github.io/blog/zig/low-level/2021/03/15/elf-linux.html">previous post</a> I asked a question, and got an answer! My question was: ‚ÄúFrom what i‚Äôve seen, linux executables are loaded into memory at 0x400000 (if someone knows why this is, please tell me!)‚Äù</p>

<p>Rafael √Åvila de Esp√≠ndola kindly replied with this answer:</p>

<blockquote>
  <p>The value is arbitrary, and not directly imposed by linux. In fact, it is the executable that sets it. In your asm file you have</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>org 0x400000
...
phdr:           ; Elf64_Phdr
  dd  1         ; p_type
  dd  5         ; p_flags
  dq  0         ; p_offset
  dq  $$        ; p_vaddr
</code></pre></div>  </div>
  <p>So you are creating a <code class="language-plaintext highlighter-rouge">PT_LOAD (type 1)</code> with a <code class="language-plaintext highlighter-rouge">p_vaddr</code> a bit above
0x400000. This is what the kernel uses to decide where to put your
binary.
BTW, it is better if the value is page aligned. It looks like the linux
kernel aligns it for you, but it is a bit more clear if the value in the
file is already aligned.
As for why 0x400000 is common, that is quite a bit of archaeology. A good
place to look is the lld history, as we had to do a bit of archaeology
when creating it. LLD started by using the smallest value that would
work: the second page. The current value was changed in
<a href="https://github.com/llvm/llvm-project/commit/c9de3b4d267bf6c7bd2734a1382a65a8812b07d9">https://github.com/llvm/llvm-project/commit/c9de3b4d267bf6c7bd2734a1382a65a8812b07d9</a>
So the reason for the 0x400000 (4MiB) is that that is the size of
superpages in some x86 modes.
It looks like the gnu linker used that for x86-64 too, but that is
probably an oversight. LLD uses 2MiB since that is the large page size in
that architecture. It was set in
<a href="https://github.com/llvm/llvm-project/commit/8fd0196c6fd1bb3fed20418ba319677b66645d9c">https://github.com/llvm/llvm-project/commit/8fd0196c6fd1bb3fed20418ba319677b66645d9c</a>
Welcome to the world of linkers :-)
Cheers,
Rafael</p>
</blockquote>

<p>I am grateful that someone went out of their way to help me.</p>

<p>The Zig self-hosted linker has this code:</p>
<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">default_entry_addr</span> <span class="o">=</span> <span class="mi">0x8000000</span><span class="p">;</span>
</code></pre></div></div>
<p>andrewrk (zig author) said the reason for putting it at 8mb:</p>

<blockquote>
  <p>note that is virtual address space; it does not actually take up 8 MiB of space</p>
  <ol>
    <li>(not important) there is a tradition of making that the entry point (citation needed)</li>
    <li>it works for both 32 and 64 bit address space</li>
    <li>it leaves plenty room for stuff to go before it, such as unmapped pages, to cause segfaults for null pointer and e.g. field access of null pointers
      <ul>
        <li>also stuff like the Global Offset Table</li>
      </ul>
    </li>
  </ol>
</blockquote>

<p>Lesson learned: one small mistake (or even change that is not ideal) can propogate through a whole industry. I was pretty interested by this :)
It is also pretty interesting that 3 different backends use 3 different values.</p>

<h1 id="brainfuck-compiler">Brainfuck Compiler</h1>

<p>In the previous post, I said that the next post would be about me writing a brainfuck compiler. In case you do not know, brainfuck is an esoteric programming language created in the 90‚Äôs. It has 8 instructions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;	increment the data pointer (to point to the next cell to the right).
&lt;	decrement the data pointer (to point to the next cell to the left).
+	increment (increase by one) the byte at the data pointer.
-	decrement (decrease by one) the byte at the data pointer.
.	output the byte at the data pointer.
,	accept one byte of input, storing its value in the byte at the data pointer.
[	if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching ] command.
]	if the byte at the data pointer is nonzero, then instead of moving the instruction pointer forward to the next command, jump it back to the command after the matching [ command.
</code></pre></div></div>

<p>You can think of it as a mini turing machine. Since it is such a simple language, it seemed like an ideal first language to implement. I implemented it from the input source code to outputting a full ELF file. I have written a compiler before, but it just emitted textual assembly and I used nasm/ld to turn it into ELF. This post will go over how I wrote it. I recommend you also read the previous post as it shows the setup for ELF part so that in this part, we can just get to emitting code.
The first thing I did was setup a <code class="language-plaintext highlighter-rouge">Code.zig</code>. In Zig, files with capital letters mean that they are structs (all files are) with fields. In this case, the only field is a</p>
<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">output</span><span class="p">:</span> <span class="p">[]</span><span class="k">const</span> <span class="kt">u8</span><span class="p">,</span>
</code></pre></div></div>

<p>field, but I left it like this so in the future I could add more fields, for storing different info about the generated code. I used the <code class="language-plaintext highlighter-rouge">r10</code> as the sort of ‚Äúarray pointer‚Äù for the code, the thing that &gt; and &lt; increment and decrement. I could have used an address in data, but decided just using a register was easier. The main loop for generating the code is small enough that I can paste it here:</p>
<blockquote>
  <p>ü§¶ moment: so I was reading the wikipedia page to write this article and realized that I read the brainfuck spec wrong. :^( I was jumping backwards instead of forwards (or maybe in even weirder ways), so most programs worked, but some didn‚Äôt. It is always good to make sure to read carefully! (and will save you a lot of time)</p>
</blockquote>

<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// generate the assembly from the brainfuck input</span>
<span class="c">/// ASSUMTIONS:</span>
<span class="c">/// at the start of the code running,</span>
<span class="c">/// dat_idx is r10,</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">gen</span><span class="p">(</span><span class="n">gpa</span><span class="p">:</span> <span class="o">*</span><span class="n">std</span><span class="p">.</span><span class="py">mem</span><span class="p">.</span><span class="py">Allocator</span><span class="p">,</span> <span class="n">bfsrc</span><span class="p">:</span> <span class="p">[]</span><span class="k">const</span> <span class="kt">u8</span><span class="p">)</span> <span class="o">!</span><span class="n">Code</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">code</span> <span class="o">=</span> <span class="n">std</span><span class="p">.</span><span class="nf">ArrayList</span><span class="p">(</span><span class="kt">u8</span><span class="p">).</span><span class="nf">init</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>
    <span class="k">errdefer</span> <span class="n">code</span><span class="p">.</span><span class="nf">deinit</span><span class="p">();</span>

    <span class="k">var</span> <span class="n">loop_stack</span> <span class="o">=</span> <span class="n">std</span><span class="p">.</span><span class="nf">ArrayList</span><span class="p">(</span><span class="kt">u64</span><span class="p">).</span><span class="nf">init</span><span class="p">(</span><span class="n">gpa</span><span class="p">);</span>
    <span class="k">defer</span> <span class="n">loop_stack</span><span class="p">.</span><span class="nf">deinit</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">bfsrc</span><span class="p">)</span> <span class="p">|</span><span class="n">c</span><span class="p">,</span> <span class="n">i</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="c">// inc dword [dat_idx]</span>
            <span class="sc">'+'</span> <span class="o">=&gt;</span> <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span> <span class="mi">0x41</span><span class="p">,</span> <span class="mi">0xff</span><span class="p">,</span> <span class="mi">0x02</span> <span class="p">}),</span>
            <span class="c">// dec dword qword [dat_idx]</span>
            <span class="sc">'-'</span> <span class="o">=&gt;</span> <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span> <span class="mi">0x41</span><span class="p">,</span> <span class="mi">0xff</span><span class="p">,</span> <span class="mi">0x0a</span> <span class="p">}),</span>
            <span class="c">// add r10, 8</span>
            <span class="sc">'&gt;'</span> <span class="o">=&gt;</span> <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span> <span class="mi">0x49</span><span class="p">,</span> <span class="mi">0x83</span><span class="p">,</span> <span class="mi">0xc2</span><span class="p">,</span> <span class="mi">0x08</span> <span class="p">}),</span>
            <span class="c">// sub r10, 8</span>
            <span class="sc">'&lt;'</span> <span class="o">=&gt;</span> <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span> <span class="mi">0x49</span><span class="p">,</span> <span class="mi">0x83</span><span class="p">,</span> <span class="mi">0xea</span><span class="p">,</span> <span class="mi">0x08</span> <span class="p">}),</span>
            <span class="c">// write(1, dat_idx, 1)</span>
            <span class="sc">'.'</span> <span class="o">=&gt;</span> <span class="k">try</span> <span class="n">write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">code</span><span class="p">),</span>
            <span class="c">// read(0, dat_idx, 1)</span>
            <span class="sc">','</span> <span class="o">=&gt;</span> <span class="k">try</span> <span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">code</span><span class="p">),</span>
            <span class="c">// NOP</span>
            <span class="sc">'['</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="c">// jumped to by the closing bracket</span>
                <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">0x90</span><span class="p">);</span>
                <span class="k">try</span> <span class="n">loop_stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">code</span><span class="p">.</span><span class="py">items</span><span class="p">.</span><span class="py">len</span><span class="p">);</span>
                <span class="c">// cmp QWORD PTR [r10],0x0</span>
                <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
                    <span class="mi">0x41</span><span class="p">,</span> <span class="mi">0x83</span><span class="p">,</span> <span class="mi">0x3a</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span>
                <span class="p">});</span>
                <span class="c">// je &lt;location of [</span>
                <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
                    <span class="mi">0x0f</span><span class="p">,</span>
                    <span class="mi">0x84</span><span class="p">,</span>
                <span class="p">});</span>
                <span class="c">// filled in by the closing bracket</span>
                <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cast</span><span class="p">(</span><span class="nb">@as</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span> <span class="mi">0</span><span class="p">)));</span>
            <span class="p">},</span>
            <span class="sc">']'</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="k">const</span> <span class="n">popped</span> <span class="o">=</span> <span class="n">loop_stack</span><span class="p">.</span><span class="nf">popOrNull</span><span class="p">()</span> <span class="k">orelse</span> <span class="p">{</span>
                    <span class="n">std</span><span class="p">.</span><span class="py">log</span><span class="p">.</span><span class="nf">emerg</span><span class="p">(</span><span class="s">"found a ] without a matching [: at index {d}"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">i</span><span class="p">});</span>
                    <span class="n">std</span><span class="p">.</span><span class="py">process</span><span class="p">.</span><span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
                <span class="p">};</span>
                <span class="c">// jmp &lt;location of [</span>
                <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
                    <span class="mi">0xe9</span><span class="p">,</span>
                <span class="p">});</span>
                <span class="c">// heavy-lifting all the jump calculations</span>
                <span class="k">const</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">code</span><span class="p">.</span><span class="py">items</span><span class="p">.</span><span class="py">len</span> <span class="o">-</span> <span class="n">popped</span><span class="p">;</span>
                <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nb">@intCast</span><span class="p">(</span><span class="kt">i64</span><span class="p">,</span> <span class="n">diff</span> <span class="o">+</span> <span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="o">..</span><span class="mi">4</span><span class="p">]);</span>

                <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">0x90</span><span class="p">);</span>
                <span class="n">std</span><span class="p">.</span><span class="py">mem</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span> <span class="n">code</span><span class="p">.</span><span class="py">items</span><span class="p">[</span><span class="n">popped</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">..</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">cast</span><span class="p">(</span><span class="nb">@intCast</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span> <span class="n">code</span><span class="p">.</span><span class="py">items</span><span class="p">.</span><span class="py">len</span> <span class="o">-</span> <span class="n">popped</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
            <span class="p">},</span>
            <span class="k">else</span> <span class="o">=&gt;</span> <span class="p">{},</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop_stack</span><span class="p">.</span><span class="py">items</span><span class="p">.</span><span class="py">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="p">.</span><span class="py">log</span><span class="p">.</span><span class="nf">emerg</span><span class="p">(</span><span class="s">"found a [ without a matching ]"</span><span class="p">,</span> <span class="o">.</span><span class="p">{});</span>
    <span class="p">}</span>
    <span class="k">try</span> <span class="n">exit0</span><span class="p">(</span><span class="o">&amp;</span><span class="n">code</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">Code</span><span class="p">{</span> <span class="p">.</span><span class="py">output</span> <span class="o">=</span> <span class="n">code</span><span class="p">.</span><span class="nf">toOwnedSlice</span><span class="p">()</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>
<p>as an example, <code class="language-plaintext highlighter-rouge">read(</code> looks like this:</p>
<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">read</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="o">*</span><span class="n">std</span><span class="p">.</span><span class="nf">ArrayList</span><span class="p">(</span><span class="kt">u8</span><span class="p">))</span> <span class="o">!</span><span class="k">void</span> <span class="p">{</span>
    <span class="c">// mov rax, 0</span>
    <span class="k">try</span> <span class="n">c</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
        <span class="mi">0xb8</span><span class="p">,</span>
        <span class="mi">0x00</span><span class="p">,</span>
        <span class="mi">0x00</span><span class="p">,</span>
        <span class="mi">0x00</span><span class="p">,</span>
        <span class="mi">0x00</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="c">// mov rdi, 1</span>
    <span class="k">try</span> <span class="n">c</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
        <span class="mi">0xbf</span><span class="p">,</span>
        <span class="mi">0x01</span><span class="p">,</span>
        <span class="mi">0x00</span><span class="p">,</span>
        <span class="mi">0x00</span><span class="p">,</span>
        <span class="mi">0x00</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="c">// mov rdx, 1</span>
    <span class="k">try</span> <span class="n">c</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
        <span class="mi">0xba</span><span class="p">,</span>
        <span class="mi">0x01</span><span class="p">,</span>
        <span class="mi">0x00</span><span class="p">,</span>
        <span class="mi">0x00</span><span class="p">,</span>
        <span class="mi">0x00</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="c">// mov rsi, r10</span>
    <span class="k">try</span> <span class="n">c</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
        <span class="mi">0x4c</span><span class="p">,</span>
        <span class="mi">0x89</span><span class="p">,</span>
        <span class="mi">0xd6</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="k">try</span> <span class="n">syscall</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>and <code class="language-plaintext highlighter-rouge">syscall(</code> looks like this</p>
<div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">syscall</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="o">*</span><span class="n">std</span><span class="p">.</span><span class="nf">ArrayList</span><span class="p">(</span><span class="kt">u8</span><span class="p">))</span> <span class="o">!</span><span class="k">void</span> <span class="p">{</span>
    <span class="k">try</span> <span class="n">c</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
        <span class="mi">0x0f</span><span class="p">,</span> <span class="mi">0x05</span><span class="p">,</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Hopefully this gives you a sense of how it all fits together. Its just machine code all the way down!</p>

<p>The way I got the x64 opcodes was just writing then in nasm, then assembling the assembly file, then using objdump to see the opcodes. I still don‚Äôt fully understand the instruction encoding (I see myself learning this in the future if I want to do more compiler stuff), so this seemed like the easiest way.
I used the <code class="language-plaintext highlighter-rouge">r10</code> x64 register as the pointer to the current cell. 
Some pain points I ran into:</p>

<ul>
  <li>
    <p>Offset math is hard! I spent a lot of time trying to do the offset math for the conditional loops. At first, my understanding of brainfuck was wrong, so that went wrong. Then I had to learn about different sizes of backwards jumps in x86 and how to represent negative numbers in binary. <code class="language-plaintext highlighter-rouge">objdump</code> helped me a lot in seeing what was wrong, I couldn‚Äôt have done this without it!</p>
  </li>
  <li>Relocation stuff. From my understanding, a relocation is a place in a binary that you need to change based on information that you get in the future.
Here is the code for making and ‚Äúdoing‚Äù the relocations:
    <div class="language-zig highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          <span class="sc">'['</span> <span class="o">=&gt;</span> <span class="p">{</span>
              <span class="c">// jumped to by the closing bracket</span>
              <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">0x90</span><span class="p">);</span>
              <span class="k">try</span> <span class="n">loop_stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">code</span><span class="p">.</span><span class="py">items</span><span class="p">.</span><span class="py">len</span><span class="p">);</span>
              <span class="c">// cmp QWORD PTR [r10],0x0</span>
              <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
                  <span class="mi">0x41</span><span class="p">,</span> <span class="mi">0x83</span><span class="p">,</span> <span class="mi">0x3a</span><span class="p">,</span> <span class="mi">0x00</span><span class="p">,</span>
              <span class="p">});</span>
              <span class="c">// je &lt;location of [</span>
              <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
                  <span class="mi">0x0f</span><span class="p">,</span>
                  <span class="mi">0x84</span><span class="p">,</span>
              <span class="p">});</span>
              <span class="c">// filled in by the closing bracket</span>
              <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cast</span><span class="p">(</span><span class="nb">@as</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span> <span class="mi">0</span><span class="p">)));</span>
          <span class="p">},</span>
          <span class="sc">']'</span> <span class="o">=&gt;</span> <span class="p">{</span>
              <span class="k">const</span> <span class="n">popped</span> <span class="o">=</span> <span class="n">loop_stack</span><span class="p">.</span><span class="nf">popOrNull</span><span class="p">()</span> <span class="k">orelse</span> <span class="p">{</span>
                  <span class="n">std</span><span class="p">.</span><span class="py">log</span><span class="p">.</span><span class="nf">emerg</span><span class="p">(</span><span class="s">"found a ] without a matching [: at index {d}"</span><span class="p">,</span> <span class="o">.</span><span class="p">{</span><span class="n">i</span><span class="p">});</span>
                  <span class="n">std</span><span class="p">.</span><span class="py">process</span><span class="p">.</span><span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
              <span class="p">};</span>
              <span class="c">// jmp &lt;location of [</span>
              <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="o">&amp;.</span><span class="p">{</span>
                  <span class="mi">0xe9</span><span class="p">,</span>
              <span class="p">});</span>
              <span class="c">// heavy-lifting all the jump calculations</span>
              <span class="k">const</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">code</span><span class="p">.</span><span class="py">items</span><span class="p">.</span><span class="py">len</span> <span class="o">-</span> <span class="n">popped</span><span class="p">;</span>
              <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">appendSlice</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nb">@intCast</span><span class="p">(</span><span class="kt">i64</span><span class="p">,</span> <span class="n">diff</span> <span class="o">+</span> <span class="mi">5</span><span class="p">))[</span><span class="mi">0</span><span class="o">..</span><span class="mi">4</span><span class="p">]);</span>

              <span class="k">try</span> <span class="n">code</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">0x90</span><span class="p">);</span>
              <span class="n">std</span><span class="p">.</span><span class="py">mem</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span> <span class="n">code</span><span class="p">.</span><span class="py">items</span><span class="p">[</span><span class="n">popped</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">..</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">cast</span><span class="p">(</span><span class="nb">@intCast</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span> <span class="n">code</span><span class="p">.</span><span class="py">items</span><span class="p">.</span><span class="py">len</span> <span class="o">-</span> <span class="n">popped</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>
          <span class="p">},</span>
</code></pre></div>    </div>
    <p>I would probably use more complicated data structures if I needed to do more complicated relocation stuff, but for now a stack (<code class="language-plaintext highlighter-rouge">std.ArrayList(u64)</code>) works fine. Basically, I just append 4 bytes of zero to the place in the elf binary where it shows where to jump to. With <code class="language-plaintext highlighter-rouge">std.mem.copy(u8, code.items[popped + 6 ..], &amp;cast(@intCast(u32, code.items.len - popped - 10 - 1)));</code> I ‚Äúdo‚Äù the relocation. For the ‚Äúcast‚Äù function, see the <a href="https://g-w1.github.io/blog/zig/low-level/2021/03/15/elf-linux.html">previous post</a>. This was probably the hardest part, getting the offset math right, but I did it! I used <code class="language-plaintext highlighter-rouge">NOP</code>s (aka 0x90) for the locations to jump to, just for simplicity.</p>
  </li>
  <li>I thought I could just use <code class="language-plaintext highlighter-rouge">inc r10</code> to move the pointer to the next cell, but this is not the case. Let‚Äôs take a look at why:
Using <a href="https://esolangs.org/wiki/Brainfuck#Cell_Size">this program</a> for calculating the size of a brainfuck cell, we get:
<code class="language-plaintext highlighter-rouge">32 bit cells</code>. It basically checks when it overflows I think. Due to the way pointers on x64 work, <code class="language-plaintext highlighter-rouge">inc</code> only increments it by one, so <code class="language-plaintext highlighter-rouge">r10</code> is pointing to the space in between a few cells. You actually need to do <code class="language-plaintext highlighter-rouge">add r10, 8</code> in order to make it work.
See this diagram (the carets are where r10 points):
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[        ][        ][        ][        ]
 ^^^^^^^^
&gt; inc r10
[        ][        ][        ][        ]
  ^^^^^^^^
</code></pre></div>    </div>
    <p>This is what happens when we just do <code class="language-plaintext highlighter-rouge">inc r10</code>, but if we <code class="language-plaintext highlighter-rouge">add r10, 8</code> then the diagram will look like this:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[        ][        ][        ][        ]
 ^^^^^^^^
&gt; add r10, 8
[        ][        ][        ][        ]
           ^^^^^^^^
</code></pre></div>    </div>
  </li>
</ul>

<p>We get the nice offset instead of a really weird one. (This also took me a while to debug)</p>

<h1 id="running-some-code">Running some code!</h1>

<p>Before we talk about the ‚Äúbugs‚Äù in <code class="language-plaintext highlighter-rouge">bz</code> (the name I chose for it. I know, soooo creative :P.) lets talk about the features:
Here is a sample <code class="language-plaintext highlighter-rouge">bz</code> session.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% rm hello
removed 'hello'
% zig build
% cat hello.bf
++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt;---.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++.------.--------.&gt;&gt;+.&gt;++.
% ./zig-out/bin/bz hello.bf -o hello
% file hello
hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
% ./hello
Hello World!
%
</code></pre></div></div>
<p>I took the hello world brainfuck program from the wikipedia article, and it works!
Lets try something a little more complicated, fibonacci:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>% cat fib.bf
&gt;++++++++++&gt;+&gt;+[
    [+++++[&gt;++++++++&lt;-]&gt;.&lt;++++++[&gt;--------&lt;-]+&lt;&lt;&lt;]&gt;.&gt;&gt;[
        [-]&lt;[&gt;+&lt;-]&gt;&gt;[&lt;&lt;+&gt;+&gt;-]&lt;[&gt;+&lt;-[&gt;+&lt;-[&gt;+&lt;-[&gt;+&lt;-[&gt;+&lt;-[&gt;+&lt;-
            [&gt;+&lt;-[&gt;+&lt;-[&gt;+&lt;-[&gt;[-]&gt;+&gt;+&lt;&lt;&lt;-[&gt;+&lt;-]]]]]]]]]]]+&gt;&gt;&gt;
    ]&lt;&lt;&lt;
]
This program doesn't terminate; you will have to kill it.
Daniel B Cristofani (cristofdathevanetdotcom)
http://www.hevanet.com/cristofd/brainfuck/
% ./zig-out/bin/bz fib.bf -o fib
% ./fib
0
1
1
2
3
5
8
13
21
34
55
89
1E01)844
2W02#633
4b045u77
7072YK10
1F]212ÔøΩ87
2=s0ÔøΩ01&lt;97
4J3Y3370ÔøΩ4
7NÔøΩ
   542"B81
12_+8*88ÔøΩ5
20t343ÔøΩÔøΩ46
^C
%
</code></pre></div></div>
<p>as you can see, for the first few fibonacci numbers it works! Then it slowly goes haywire. I think the program actually calculates the right numbers as 1E01)844 looks like 144 and 2W02#633 looks like 233. I think I just have some weird miscompilation that I can‚Äôt identify for printing the numbers. I am sad. But, this is good enough for now. I officially declare this project ‚Äúdone‚Äù for now. You can see the code for this commit <a href="https://github.com/g-w1/zelf/commit/62c3bac27ad1b2e195626847f3b50181cf61357a">here</a>.</p>

<p>Sources:
https://en.wikipedia.org/wiki/Brainfuck#Commands 
https://esolangs.org/wiki/Brainfuck</p>
